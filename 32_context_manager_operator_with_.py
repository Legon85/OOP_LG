# реализация процесса открытия, чтения и закрытия файла посредством try-except-finally:

fp = None
try:
    fp = open("myfile.txt") #  открытие файла
    for t in fp:
        print(t) #  чтение данных из файла
except Exception as e: # если при произошли ошибки при чтении переходим в блок except
    print(e)
finally: # и в любом случае переходим в блок finally где закрывается файл функцией .close()
    if fp is not None:
        fp.close()


# с помощью МЕНЕДЖЕРА КОНТЕКСТА можно сократить запись вышеописанного процесса:

fp = None
try:
    with open("myfile.txt") as f:
        for t in fp:
            print(t)
except Exception as e:
    print(e)

# удобство менеджера в том, что после работы с файлом он его автоматически закрывает.причём вне
# зависимости от того произошли ошибки или нет

# реализуем через класс с помощью менеджера контекста логику, где мы изменяем параметры вектора в том случае
# если не произошло никаких ошибок. Если же ошибки при изменении произошли, необходимо оставить вектор без
# изменений:


class DefenderVector: # DefenderVector(v1)
    def __init__(self, v): # 3. инициализатор сохраняет ссылку на вектор v1 - [1, 2, 3]
        self.__v = v

    def __enter__(self): # 4. здесь создаётся копия списка v1 ([1, 2, 3])
        self.__temp = self.__v[:] # в переменной __temp сохраняем ссылку на копию __v (то же, что и v1)
        return self.__temp # далее эта копия возвращается,а значит,что действия в теле контектного менеджера
        # теперь будут производится с копией v1! <DefenderVector(v1) as dv> означает <self.__tmp as dv>

    def __exit__(self, exc_type, exc_val, exc_tb): # в нашем случае параметр exc_type не будет None т.к. ошибка была!
        if exc_type is None: # т.к. у нас произошла ошибка, то данное условие примет значение False
            self.__v[:] = self.__temp # и в данном месте не произойдёт изменение оригинального v1 на self.__temp
        return False # 6. поэтому вернётся False


v1 = [1, 2, 3]
v2 = [2, 3]

try: # 1.пробуем выполнить контекстный мененджер
    with DefenderVector(v1) as dv: # 2.в контекст.менеджере фомироуется класс DefenderVector с параметром исходного вектора v1
        for i, c in enumerate(dv): # 5.здесь меняем значения копии v1(__temp) складывая со значениями вектора v2(по задумке)
            dv[i] += v2[i] # но при складывании значений списка происходит ошибка, т.к. списки не равны по кол-ву элементов
            # Но т.к.контекстный менеджер завершает работу, несмотря на исключения,то мы переходим в метод __exit__
except:
    print("Ошибка")  # 7. далее переходим на блок except и выводим "Ошибка"

print(v1) # 8. И,наконец, выводим вектор v1,что бы показать, что он не изменился -> [1, 2, 3]


# если же колличество параметров исходных векторов бедет равное, то ошибок не призойдет и вектор v1
# изменится алгоритм будет следующий:

class DefenderVector: # DefenderVector(v1)
    def __init__(self, v): # 3. инициализатор сохраняет ссылку на вектор v1 - [1, 2, 3]
        self.__v = v

    def __enter__(self): # 4. здесь создаётся копия списка v1 ([1, 2, 3])
        self.__temp = self.__v[:] # в переменной __temp сохраняем ссылку на копию __v (то же, что и v1)
        return self.__temp # далее эта копия возвращается,а значит,что действия в теле контектного менеджера
        # теперь будут производится с копией v1! <DefenderVector(v1) as dv> означает <self.__tmp as dv>

    def __exit__(self, exc_type, exc_val, exc_tb): # в этом случае параметр exc_type будет None т.к. ошибок не было!
        if exc_type is None: # т.к. у нас не произошло ошибок, то данное условие примет значение True
            self.__v[:] = self.__temp # 6.и в данном месте произойдёт изменение оригинального v1 на self.__temp
        return False


v1 = [1, 2, 3]
v2 = [2, 3, 1]

try: # 1.пробуем выполнить контекстный мененджер
    with DefenderVector(v1) as dv: # 2.в контекст.менеджере фомироуется класс DefenderVector с параметром исходного вектора v1
        for i, c in enumerate(dv): # 5.здесь меняем значения копии v1(__temp) складывая со значениями вектора v2(по задумке)
            dv[i] += v2[i] # при складывании значений списка ошибок не происходит т.к. списки равны по длине
            # и мы переходим в метод __exit
except:
    print("Ошибка")  # в блок except в данном случае не переходим

print(v1) # 7. И,наконец, выводим вектор v1,что бы показать, что он изменился!!! -> [3, 5, 4]
