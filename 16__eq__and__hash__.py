print(hash(123))
print(hash("Python"))
print(hash((1, 2, 3)))  # -> 529344067295497451
print(hash((1, 2, 3)))  # -> 529344067295497451 - hash от одинаковых объектов обязательно одинаковы
# но если объекты одинковы это не означает, что их hash будут одинаковы !!!
# однако если hash не равны мы может абсолютно точно сказать,что и объекты не равны
# иными словами:

# если объекты a == b (равны), то равен и их hash
# Равные хеши: hash(a) == hash(b) гарантируют равенство оъектов
# Если хеши не равны: hash(a) != hash(b), то объекты не равны
# хеши можно вычислять только для не изменяемых объектов !!!
# хеши используются в словарях в качестве ключей и ключи поэтому могут быть только неизменяемыми типами
# поэтому в действительности ключ словаря, например d["python"] имеет конструкцию (хэш ключа, ключ)

class Point:
    def __init__(self, x , y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1), hash(p2), sep="\n") # возможен вывод хешей экземпляров класса т.к. экземляры являются неизменяемыми
#  на данный момент интер-р выводит разные хеши т.к. воспринимает объекты p1 (Point(1, 2) и p2 как разные
# проверить это можно проверив из равениство:
print(p1 == p2)  #  -> False
# но это поведение можно переопределить используя метод __eq__:

class Point:
    def __init__(self, x , y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p2) # теперь поверка равенства объектов даёт нам True
# print(hash(p1), hash(p2), sep="\n") # но когда мы попытаемся вывести хеши выдаст ошибку
# unhashable type (для проверки раскоментировать строку выше)
# т.к. после вышеописанных манипуляция перестает работать хеш
# для того чтоб исправить это поведение нужно определить метод  __hash__

class Point:
    def __init__(self, x , y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        """ по сути метод подменяет вычисление хеша от объектов
        на вычисление хеша от координат(свойств объекта"""
        return hash((self.x, self.y)) # определяет хеши координат(а координаты равные) и хеш вычисляется


p1 = Point(1, 2)
# p1 = Point(10, 20)
p2 = Point(1, 2)

print(p1 == p2)
print(hash(p1), hash(p2), sep="\n") # теперь хеши объектов определяются

# что нам дают вышеописанные методы: если создать словарь с ключами в качестве этих объектов(p1 и p2)
d = {}
d[p1] = 1
d[p2] = 2
print(d)
# То! при активных методах __eq__, __hash__ мы получим результат
# -> {<__main__.Point object at 0x00000205EABA7E50>: 2}
# а если закоментировать эти методы, то получим
# -> {<__main__.Point object at 0x000001F6BAF27EB0>: 1, <__main__.Point object at 0x000001F6BAF27E50>: 2}
# в первом случае поскольку объекты равны, то равны и их хеши поэтому формируется всего 1 ключ
# а во втором случае объекты не равны поэтому не равны и их хеши и формируется 2 разных ключа
# но если в первом объекте поменять значения координат
# например p1 = Poin(10, 20)(раскоментировать для проверки)
# то исходя из условия в методе __eq__ получим не равные объекты
# и сформируется словарь из 2 разных ключей и значений
# таким образом можно тонко настраивать работу функции хеш для объектов и классов