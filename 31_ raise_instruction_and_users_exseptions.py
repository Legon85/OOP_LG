# из вышеизуыенного понятно,что есил в коде есть ошибки то интерпретатор генерирует на ошибки.
# Но как это происходит - благодаря интсрукции "raise". С помощью rais мы можем, впрнципе,
# самостоятельно генерировать любые ошибки связанные с предполагаемо возможными ошибками в коде!!!!

# то есть если, напрмер, у нас есть текст с ошибкой в результате которой мы получаем исключение:
# print("Я к вам пишу - чего же боле?")
# print("Что я могу еще сказать?")
# print("Теперь, я знаю, в вашей воле")
# 1 / 0  # ->ZeroDivisionError: division by zero
# print("Меня презреньем наказать.")
# print("Но вы, к моей несчастной доле")
# print("Хоть каплю жалости храня,")
# print("Вы не оставите меня.")
# print()

# то это же исключение мы можем сгенерировать сами с помощью инструкции raise. например:

# print("Я к вам пишу - чего же боле?")
# print("Что я могу еще сказать?")
# print("Теперь, я знаю, в вашей воле")
# raise ZeroDivisionError # в данном случае мы сами сгенерировали ошибку(исключение) с помощью raise
# print("Меня презреньем наказать.")
# print("Но вы, к моей несчастной доле")
# print("Хоть каплю жалости храня,")
# print("Вы не оставите меня.")
# print()

# так же в скобки рядом с исключение можно прописывать текст описывающий характер исклюяения:

# print("Я к вам пишу - чего же боле?")
# print("Что я могу еще сказать?")
# print("Теперь, я знаю, в вашей воле")
# raise ZeroDivisionError("Деление на ноль") # -> ZeroDivisionError: Деление на ноль
# # прописываем в скобках необходимую информацию для вывода прогармисту
# print("Меня презреньем наказать.")
# print("Но вы, к моей несчастной доле")
# print("Хоть каплю жалости храня,")
# print("Вы не оставите меня.")
# print()

# из записи ZeroDivisionError("Деление на ноль") видно,что это есть объект класса ZeroDivisionError. Поэтому мы можем
# его определить в какой-либо переменной е = ZeroDivisionError("Деление на ноль")

# print("Я к вам пишу - чего же боле?")
# print("Что я могу еще сказать?")
# print("Теперь, я знаю, в вашей воле")
# e = ZeroDivisionError("Деление на ноль")
# raise e
# print("Меня презреньем наказать.")
# print("Но вы, к моей несчастной доле")
# print("Хоть каплю жалости храня,")
# print("Вы не оставите меня.")
# print()

# если интерпретатор сам может генерировать исключения, то в каких может понадобиться инструкция rase?
# Естесственно в специфических(не предопределённых интерпретатором) случаях.
# например елси в одном из методов(send_data) класса PrinData программист хочет прописать исключение в случае
# если данные не могут быть отправлены в принтер. Естесственно в python по-умолчанию таких исключений нет
# и мы должны прописать его сами:

# class PrintData:
#     def print(self, data):
#         self.send_data(data) # в данном случае метод print вызывает метод send_data
#         print(f"печать: {str(data)}")
#
#     def send_data(self, data):
#         if not self.send_to_print(data): # а здесь метод send_data с помощью обращения к методу send_to_print проверяет
#             # могут ли данные быть отправлены в принтер
#             raise Exception("принтер не отвечает") # и если,например, данные не могут быть отправлены,
#             # то мы генерируем самостоятельно исключение с помощью raise!! вот для чего нужен raise!
#
#     def send_to_print(self, data):
#         return False
#
#
# p = PrintData()
# p.print("123") # получаем -> Exception: принтер не отвечает

# данное исключение можно обработать:

class PrintData:
    def print(self, data):
        self.send_data(data)
        print(f"печать: {str(data)}")

    def send_data(self, data):
        if not self.send_to_print(data):
            raise Exception("принтер не отвечает")
    def send_to_print(self, data):
        return False
        # return True # -> печать: 123 для проверки раскоментить и закоментить вышестоящую строку


p = PrintData()
try:
    p.print("123")
except Exception:
    print("принтер не отвечает")

# здесь мы используем для генерации исключений класс Exception т.к. он является основным базовым классом
# для подавляющего большинства исключений
# Попробуем создать своё исключение с использование базового класса Exception

# class ExceptionPtintSendData(Exception): # наш класс исключение наследуется от калсса Exception
#     """Класс исключение при отправки данных принтеру"""
#
# class PrintData:
#     def print(self, data):
#         self.send_data(data)
#         print(f"печать: {str(data)}")
#
#     def send_data(self, data):
#         if not self.send_to_print(data):
#             raise ExceptionPtintSendData("принтер не отвечает") # теперь вместо Exception
#             # можем пропсывать наш дочерний класс
#     def send_to_print(self, data):
#         return False
#         # return True # -> печать: 123 для проверки раскоментить и закоментить вышестоящую строку
#
#
# p = PrintData()
# p.print('123') # -> __main__.ExceptionPtintSendData: принтер не отвечает.Здесь видно, что теперь стандарное исключение
# класса Exception отрабатывает через наш дочерний класс ExceptionPtintSendData
# то есть если теперь раскоментироват блок try except
# то при попадании в написанное нами исключение ExceptionPtintSendData в блоке except будет сразу понятно, что исключение
# связано с тем, что мы не можем отправить в принтер какие-либо данные. И далее мы можем выполнить какой либо алгоритм
# действий исходя из этого. В этом и есть ценность наших собственных классов-исключений !!!
# try:
#     p.print("123")
# except ExceptionPtintSendData:
#     print("принтер не отвечает")

# кроме того мы можем в нашем собственном классе-исключении определять какие-либо методы.
# Добавим методы,которые при срабатывании нашего исключения будут дописывать слово "ошибка" перед основной
# информацией об ошибке а именно -> __main__.ExceptionPtintSendData: Ошибка: принтер не отвечает

# class ExceptionPtintSendData(Exception): # наш класс исключение наследуется от калсса Exception
#     """Класс исключение при отправки данных принтеру"""
#     def __init__(self, *args): # тут,получая исключение, мы через __init__ присваиваем ему св-во 'message' которое будет
#         # по сути являтся той строкой что мы передаём в исключении ("принтер не отвечает") если она там прописана, а если
#         # не прописана, то будет None
#         self.message = args[0] if args else None
#
#     def __str__(self): # тут мы с помощью метода __str__ выводим нужный текст с словом ошибка и message
#         return f"Ошибка: {self.message}" # -> Ошибка: принтер не отвечает
#
#
# class PrintData:
#     def print(self, data):
#         self.send_data(data)
#         print(f"печать: {str(data)}")
#
#     def send_data(self, data):
#         if not self.send_to_print(data):
#             raise ExceptionPtintSendData("принтер не отвечает")
#     def send_to_print(self, data):
#         return False
#         # return True # -> печать: 123 для проверки раскоментить и закоментить вышестоящую строку


p = PrintData()
p.print('123') # -> __main__.ExceptionPtintSendData: Ошибка: принтер не отвечает
# try:
#     p.print("123")
# except ExceptionPtintSendData:
#     print("принтер не отвечает")


# кроме этого можно составлять иерархию наследования своих собственных классов исключений, чтобы можно было гипко
# выводить информацию о тех или иных ошибках    например:
# Добавим общий класс ExceptionPrint для вывода каких-либо иных ошибок помимо ошибки отправки данных на печать

class ExceptionPtint(Exception):
    """Общий класс исключения принтера"""


class ExceptionPtintSendData(ExceptionPrint): # терерь наш класс исключение наследуется от ещё одного нашего класса
    """Класс исключение при отправки данных принтеру"""
    def __init__(self, *args):
        self.message = args[0] if args else None

    def __str__(self):
        return f"Ошибка: {self.message}"


class PrintData:
    def print(self, data):
        self.send_data(data)
        print(f"печать: {str(data)}")

    def send_data(self, data):
        if not self.send_to_print(data):
            raise ExceptionPtintSendData("принтер не отвечает")
    def send_to_print(self, data):
        return False
        # return True # -> печать: 123 для проверки раскоментить и закоментить вышестоящую строку


p = PrintData()
# p.print('123')
# теперь можно добавить еще один except блок в котором будет определён наш новый класс ExceptionPtintSendData
# и в таком случае если у нас присходит ошибка связанная с отправкой данных на пирнтер,то сработает наше прежнее
# исключение, а елси произойдёт какая-либо другая ошибка, то ExceptionPtintSendData уже не сработает, зато сработает
# ExceptionPtint (общая ошибка печати)  что очень полезно
try:
    p.print("123")
except ExceptionPtintSendData:
    print("принтер не отвечает")
except ExceptionPtint:
    print("Общая ошибка печати")
