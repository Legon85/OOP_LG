# Предположим у нас есть некий многопоточный процесс и в каждом потоке создаётся свой экземпляр класса
# ThreadData(), но нам бы хотелось чтоб все экземпляры имели единые локальные свойства: name, data, id
# (общие для всех экземпляров класса ThreadData) и чтоб изменение любого локального св-ва одного из экземпляров
# отражалось бы на локальных св-вах и других экземпляров. Это и есть МОНОСОСТОЯНИЕ. Реализуется оно относительно
# просто: В классе создается в качестве св-ва класса словарь __shared_attrs, который и будет содержать общие
# локальные св-ва экземпляров. Ключами в этом словаре и будут имена локальных св-тв, ну а значениями словаря -
# значения локальных св-тв. А в инициализаторе класса мы прописываем, что словари экземпляров класса __dict__,
# которые, как известно, хранят как раз-таки локальные св-ва экземпляров, будут ссылаться на тот самый,
# определённый нами в классе описанный выше словарь __shared_attrs

class ThreadData:
    __shared_attrs = {
        'name': 'thread_1',
        'data': {},
        'id': 1
    }

    def __init__(self):
        self.__dict__= self.__shared_attrs

# Создадим несколько экземпляров класса ThreadData, чтобы убедиться, что их словари __dict__ автоматически
# формируются на основании словаря __shared_attrs:

th1 = ThreadData()
th2 = ThreadData()
print(th1.__dict__)  # {'name': 'thread_1', 'data': {}, 'id': 1}
print(th2.__dict__)  # {'name': 'thread_1', 'data': {}, 'id': 1}
# По итогу видим, что у обоих экземпляров сформировались одни и те же локальные св-ва на основе словаря
# __shared_attrs. Что и является МОНОСОСТОЯНИЕМ

# Чтобы проверить, являются ли эти локальные св-ва экземпляров истинно общими, сначала поменяем в одном из них
# значение св-ва и посмотрим, изменилось ли тоже св-во в другом, а потом создадим в одном из них новые
# св-ва и проверим, создались ли такие же в другом:

th2.id = 3
print(th2.__dict__)  # {'name': 'thread_1', 'data': {}, 'id': 3}
print(th1.__dict__)  # {'name': 'thread_1', 'data': {}, 'id': 3} видим, что св-во id в экземпляре th1 тоже
# изменило своё значение

th1.attr_new = 'new_attr'
print(th2.__dict__)  # {'name': 'thread_1', 'data': {}, 'id': 3, 'attr_new': 'new_attr'} -  видим, что в экземпляре
# th2 так же появилось св-во attr_new

# В общем и целом получается, что локальная область имен для этих экземпляров оказывается едино. И для любого
# количества экземпляров оно будет едино и будет определяться словарём __shared_attrs
