class Geom:
    name = "Geom"


class Line:
    def draw(self):
        print("Drawing the line")


g = Geom()
print(g.name) # можно вызвать свойство name класса Geom но нельзя вызвать draw другого класса
l = Line()
l.draw() # при создании другого экземпляра (класс Line) drow работает поскольку это разные классы


# но при необходимости можно настроить связь между классами для этого в скобках прописываем класс
# свойствами которого собираемся пользоваться в текущем классе:

class Line(Geom): # это и есть наследование Geom-базовый(родительский)класс, Line-подкласс(дочерний)
    def draw(self):
        print("Drawing the line")

l = Line()
print(l.name) # теперь в экз-ре класса line выводится свойство класса Geom!!!

# пример для чего может понадобиться наследование
# допустим надо определить 2 класса Line и Rect в которых будут дублирующиеся методы set__coords:

class Geom:
    name = "Geom"


class Line(Geom):
    def draw(self):
        print("Рисование линии")

    def set__coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


class Rect(Geom):
    def draw(self):
        print("Рисование прямоугольника")

    def set__coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2

# чтобы избавиться от дублирования и используется наследование.
# для этого определяем set__coords в базовом классе Geom. тем самым как бы выносим его:

class Geom:
    name = "Geom"

    def set__coords(self, x1, y1, x2, y2): # Важно !!! в данном случае(при наследовании)
        # параметр self может ссылатья не только на объект класса Geom,
        # но и на объекты дочерних классов Line и Rect
        # в зависимости от того откуда он был вызвван
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


class Line(Geom):
    def draw(self):
        print("Рисование линии")


class Rect(Geom):
    def draw(self):
        print("Рисование прямоугольника")


g = Geom()
l = Line()
r = Rect()
g.set__coords(3, 4, 5, 6) # в данно случае self отрабатывает как ссылка на объ-т класса Geom
l.set__coords(1, 1, 2, 2) # здесь же self отработал как ссылка на объ-т класса Line
r.set__coords(1, 1, 2, 2)
print(l.__dict__)
print(r.__dict__)
print(g.__dict__)

#-----------------------------------------------------------------------------------------
# но всё же для чего еще нужно наследование?
# например если в базовом классе Geom определить и метод draw() тоже, то при вызове метода
# set_coords из дочерних классов произойдёт вызов метода draw для каждого дочернего в отдельности

class Geom:
    name = "Geom"

    def set__coords(self, x1, y1, x2, y2): # Важно !!! в данном случае(при наследовании)
        # параметр self может ссылатья не только на объект класса Geom,
        # но и на объекты дочерних классов Line и Rect
        # в зависимости от того откуда он был вызвван
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.draw()


class Line(Geom):
    def draw(self):
        print("Рисование линии")


class Rect(Geom):
    def draw(self):
        print("Рисование прямоугольника")


# g = Geom()
l = Line()
r = Rect()
# g.set__coords(3, 4, 5, 6) #
l.set__coords(1, 1, 2, 2) # вызов метода draw из метода базового класса set__coords
# для объекта дочернего класса l
r.set__coords(1, 1, 2, 2) # вызов метода draw из метода базового класса set__coords
# для объекта дочернего класса r
# !!! но в данном случае нельзя вызывать метод set__coords из объекта базового класса Geom
# (g.set_coords) поскольку для объекта g ни какого метода draw() не определено было
# и в результате будет ошибка

# касаемо областей видимости так же надо заметить, что если в дочернем классе опредлить
# атрибут с таким же именем как и в базовом, то при вызове этого этого атрибута через
# объект дочернего класса вернётся атрибут объекта дочернего класса т.к. будет найден
# первым. И такое поведение называется переопределением атрибута и подсвечивается кружком со
# стерлочкой :

class Geom:
    name = "Geom"

    def set__coords(self, x1, y1, x2, y2): # Важно !!! в данном случае(при наследовании)
        # параметр self может ссылатья не только на объект класса Geom,
        # но и на объекты дочерних классов Line и Rect
        # в зависимости от того откуда он был вызвван
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2

    def draw(self):
        print("Рисование примитива")

class Line(Geom):
    name = "Line"  # атрибут name переопределяется в дочернем калссе (указано кружком со стрелкой слева)
    def draw(self): # тоже самое и с методами!!!
        print("Рисование линии")


class Rect(Geom):
    pass


g = Geom()
g.set__coords(0, 0, 0, 0)
l = Line()
r = Rect()
print(l.name) # -> вернёт "Line" находящийся в локально обл.видимости класса Line
print(r.name) # -> вернёт "Geom" т.к. в лок.обл.вид класса Rect нет атрибута name
# и он найдётся в базовом классе Geom
l.draw() # -> "рисование линии" в данном случае идёт вызов метода draw из-под объекта l
r.draw() # -> "рисование примитива" в данном случае в объекте r метод draw не нашёлся
# и поиск продолжился в классе Geom