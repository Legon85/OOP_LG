# простейшее определение класса
class Point:
    pass


# Добавим переменные внутри класса (называют атрибутами или свойствами класса)


class Point:
    color = 'red'
    circle = 2


#  способы обращения к переменныv
print(Point.color)  # -> red
# чтоб перезаписать св-во:
Point.color = "black"
print(Point.color)  # -> black

# для просмотра всех св-тв используется __dict__:
print(Point.__dict__)  # -> {'__module__': '__main__', 'color': 'black', 'circle': 2,
# '__dict__': <attribute '__dict__' of 'Point' objects>,
# '__weakref__': <attribute '__weakref__' of 'Point' objects>, '__doc__': None}

# создадим объект(экземпляр) класса:
a = Point()
b = Point()

# явно определить, что переменные a, b ссылаются на объекты класса Point можно следующими способами:
print(type(a))  # <class '__main__.Point'>
print(type(a) == Point)  # True
print(isinstance(a, Point))  # True

# объекты a, b сейчас не содержат никаких атрибутов. Чтоб посмотреть исп. dict:
print(a.__dict__)  # {}
print(b.__dict__)  # {}

# но обращаться к св-вам класса можно:
print(a.color)  # black

# но изменять объектом св-ва класса нельзя. При попытке изменения мы лишь создадим собственное св-во
# объекта:
a.color = 'green'
print(a.color)
print(a.__dict__)  # {'color': 'green'} создалось св-вj объекта
# Поэтому при записи типа a.color если в пространстве имён объекта a нет св-ва color, то оно созадстся
# автоматически
# так же динамически можно создавать и новые св-ва класса Point:
Point.type_pt = 'disc'
print(Point.__dict__)  # Теперь в Point появилось новое св-во type_pt

# так же можно создавать новые атрибуты класса с помощью setattr функции:
setattr(Point, 'prop', 1)
print(Point.__dict__)  # добавилось св-во prop со значением 1

# с помощью setattr можно и просто менять уже существующие значения атрибутов:
setattr(Point, 'type_pt', 'square')
print(Point.__dict__)  # type_pt стало

# если попытаться прочитать несуществующее св-во класса (например (print(Poin.circle)), то очевидно
# получим ошибку. Но этого поведения можно избежать используя метод getattr, указав ему в качестве
# второго аргумента значение, которое будет выводиться в случае отсутствия св-ва класса(например False):
print(getattr(Point, 'a', False))  # False

# для удаления атрибутов из того или иного пространства имён используется оператор del
print(Point.prop)  # 1
del Point.prop
print(Point.__dict__)  # prop удалилось из словаря

# так же атрибуты можно удалять с помощью метода delattr:
delattr(Point, 'type_pt')
print(Point.__dict__)  # удалено type_pt

# Если попытаться ещё раз удалить уже удалённый атрибут, то очевидно получим ошибку, поэтому перед
# удалением желательно проверять наличие атрибутов. Поможет в этом метод hasattr:
print(hasattr(Point, 'prop'))  # Вернёт False т.к. prop мы уже удалили
# причём если через метод hasattr запросить атрибут, которого нет у объекта в локальном пространстве
# имён, но который есть в пространстве имён класса, то hasattr вернёт True
print(hasattr(a, 'circle'))  # True

# Однако же метод delattr наоборот, при попытке удаления св-ва, которого нет в локальном пространстве
# имён вернёт ошибку, т.к. он не будет удалять св-во класса если одноименного св-ва не было найдено в
# пространстве имён объекта. А вот если одноимённое св-во есть в пространстве имён объекта,
# то он удалит св-во в пространстве имён объекта:
delattr(a, 'color')
print(a.__dict__)  # {} color: green удалено


# Так же мы можем динамически создавать в объектах класса одинаково названные св-ва с разными
# значениями. То есть в каждом пространстве имён каждого объекта создаются абсолютно независимые св-ва.


class Point:
    color = 'red'
    circle = 2


a = Point()
b = Point()

a.x = 1
a.y = 2

b.x = 3
b.y = 4

print(a.__dict__, b.__dict__)  # {'x': 1, 'y': 2} {'x': 3, 'y': 4}


# так же в любом классе можно прописывать документ-строку:
class Point:
    """Класс для представления координат точек на плоскости"""
    color = 'red'
    circle = 2


# при необходимости можно вывести эту строку с помощью __doc__
print(Point.__doc__)  # Класс для представления координат точек на плоскости
