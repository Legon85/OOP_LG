class Point:
    color = 'red'
    circle = 2

    def set_coords(self, x, y):
        self.x = x
        self.y = y

    def get_coords(self):
        return self.x, self.y


pt = Point()
pt.set_coords(1, 2)  # формирование лок.св-тв вручную
print(pt.__dict__)


# Рассмотренный в прошлом уроке способ формирования у экземпляров класса локальных св-тв на самом
# деле не очень удобен, т.к. при каждом новом экземпляре нужно будет снова вручную создавать эти локальные
# св-ва. Для таких целей в python встроен специальный магические метод с двойным нижним подчеркиванием
# __init__ Он позволяет автоматически формировать заданные в нём св-ва у каждого вновь созданного
# экземпляра

# Используем метод __init__ для формирования лок.св-тв:
#
class Point:
    color = 'red'
    circle = 2

    def __init__(self):
        self.x = 0  # прописываем лок. Св-ва, которые будут автоматически формироваться у объектов класса
        self.y = 0


pt = Point()
print(pt.__dict__)  # {'x': 0, 'y': 0} лок. св-ва сформировались автоматически!


# Чтобы лок.св-тва создавались не по умолчанию 0 как в примере выше, а те которые нужны нам, нужно
# в методе __init__ указать возможность их добавления в качестве аргументов. При этом их необходимо
# будет указывать при создании объекта в скобах после имени класса
class Point:
    color = 'red'
    circle = 2

    def __init__(self, x, y):  # прописываем возможность добавления своих значений локальных св-тв
        self.x = x
        self.y = y


pt = Point(2, 4)  # указываем значения локал. св-тв
print(pt.__dict__)  # {'x': 2, 'y': 4}


# так же в качестве параметров метода __init__ можно задавать значения по умолчанию. Тогда после имени
# класса можно не прописывать аргументы. Они будут взяты по умолчанию
class Point:
    color = 'red'
    circle = 2

    def __init__(self, x=0, y=0):  # прописываем параметры локальных св-тв по умолчанию
        self.x = x
        self.y = y


pt = Point()  # можно не указывать значения локал. св-тв
print(pt.__dict__)  # {'x': 0, 'y': 0}


# Так же существует магический метод __del__ и вызывается он непосредственно перед удалением объекта
# сборщиком мусора python. То есть, например, когда у нас переменная pt перестаёт ссылаться на объект
# ссылка на который ей была присвоена. Грубо говоря, например было pt = Point(), а далее прописали
# pt = 0. Теперь pt ссылается на 0 и сборщик мусора удаляет объект класса Point. Так вот перед этим и
# вызывается метод __del__:

class Point:
    color = 'red'
    circle = 2

    def __init__(self, x=0, y=0):  # прописываем параметры локальных св-тв по умолчанию
        self.x = x
        self.y = y

    def __del__(self):
        print(f"удаление экземпляра {self}")


pt = Point()  # можно не указывать значения локал. св-тв
# python выводит: удаление экземпляра <__main__.Point object at 0x000001991445FFD0>
